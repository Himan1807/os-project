\documentclass[10pt,twocolumn]{article}
\usepackage[utf8]{inputenc}
\usepackage{geometry}
\usepackage{booktabs}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{url}

\geometry{a4paper, margin=0.75in}
\hypersetup{colorlinks=true, linkcolor=blue, citecolor=red}

\title{Creating OShell \& Optimizing Mathematical Execution Through Process Management Innovations}
\author{Akshat Sharma (2310110028), Himanshu Singh (2310110668), 
\\ Arnav Anand (2310110429), Himanshu Raj (2310110480) \\ 
Department of Computer Science \\
Shiv Nadar University, Greater Noida, India}
\date{}

\lstset{
    basicstyle=\ttfamily\footnotesize,
    breaklines=true,
    frame=lines,
    numbers=left,
    numberstyle=\tiny\color{gray},
    keywordstyle=\color{blue},
    commentstyle=\color{green!40!black},
    stringstyle=\color{red},
    showstringspaces=false,
    language=C
}

\begin{document}

\maketitle

\begin{abstract}
This paper presents OShell, an enhanced Unix shell, created in C, demonstrating tremendous acceleration of mathematical operations through process management optimizations. By combining in-process batch execution with algorithmic improvements for exponentiation, OShell achieves significant performance gains while maintaining POSIX compliance. Comprehensive benchmarks against PowerShell 7.3 and Bash 5.1 reveal that 92\% of total performance gains result from reduced process creation overhead rather than computational enhancements. The system's design draws lessons from historical shell architectures while addressing modern computational requirements.
\end{abstract}

\section{Introduction}
Modern shell environments face performance challenges with computational workloads due to inherent process creation costs \cite{bournesh}. OShell addresses this through three key innovations:

\begin{itemize}
\item Hybrid execution model combining batch and interactive modes
\item Logarithmic-time exponentiation using bitwise operations
\item Optimized pipe buffer management
\end{itemize}

Our work builds on Bourne's original shell design principles \cite{bournesh} while incorporating insights from modern shell research \cite{modernshell}.

\section{Related Work}
\subsection{Historical Foundations}
Bourne's original shell design \cite{bournesh} emphasized simplicity and process composition. While revolutionary, its computational model predates modern multi-core architectures.

\subsection{Modern Shell Research}
Greenberg et al. \cite{modernshell} identify three key challenges for future shells: parallelism, JIT compilation, and type safety. OShell addresses the parallelism challenge through its hybrid execution model.

\subsection{Benchmarking Methodologies}
Krysl and Chen's computational benchmarking framework \cite{bench} informs our evaluation methodology, particularly in measuring both algorithmic and systemic performance factors.

\section{System Design}

\subsection{Execution Pipeline}
\begin{lstlisting}[caption={Hybrid Execution Algorithm},xleftmargin=2em]
while (1) {
    cmd = read_input();
    if (is_math(cmd)) {
        batch_evaluate(cmd);  // Avoid fork()
    } else {
        traditional_fork_exec(cmd);
    }
}
\end{lstlisting}

\subsection{Mathematical Optimization}
We have optimized OShell by introducing a dedicated execution mechanism specifically designed for handling exponential expressions. This enhancement leverages bitwise operations to improve computational efficiency.
For exponentiation, we employ the following recursive strategy:

\begin{equation}
x^n = \begin{cases} 
1 & n = 0 \\
(x^{n/2})^2 & n \text{ even} \\
x \cdot (x^{(n-1)/2})^2 & n \text{ odd}
\end{cases}
\end{equation}

Implemented via bitwise operations:

\begin{lstlisting}[caption={Exponentiation by Squaring},xleftmargin=2em]
double parallel_pow(double base, int exp) {
    double result = 1;
    while (exp > 0) {
        if (exp & 1) result *= base;
        base *= base;
        exp >>= 1;
    }
    return result;
}
\end{lstlisting}
\subsection{Optimization: Batch Mode Execution}
The shell's \texttt{-b} mode executes calculations repeatedly in a single process:

\begin{lstlisting}[language=C,caption={Batch Execution Without Process Overhead},xleftmargin=2em]
if (argc == 4 && strcmp(argv[1], "-b") == 0) {
int reps = atoi(argv[2]);
for (int i = 0; i < reps; i++) { // No process creation overhead
eval_expr(...);
}
}
\end{lstlisting}

\textbf{Why this helps:}
\begin{itemize}
\item Eliminates process creation costs (\texttt{fork()}/\texttt{exec()})
\item Avoids repeated shell parsing (tokenization, pipe setup)
\item Maintains memory residency between iterations
\end{itemize}

\section{Benchmark Methodology}

\subsection{Experimental Setup}
\begin{itemize}
\item Hardware: Intel i7-11800H (8 cores), 32GB DDR4
\item OS: Linux 5.15 (WSL2), Windows 11 22H2
\item Baselines: PowerShell 7.3.4, Bash 5.1.16
\end{itemize}

\subsection{Benchmark Suite}
\begin{table}[ht]
\centering
\caption{Benchmark Components}
\label{tab:benchmarks}
\begin{tabular}{@{}ll@{}}
\toprule
\textbf{Test} & \textbf{Purpose} \\
\midrule
Math throughput & Exponentation (2\textsuperscript{30}) \\
Process overhead & /bin/true execution \\
Pipe latency & 10-stage pipe chain \\
\bottomrule
\end{tabular}
\end{table}

\section{Results}

\begin{table}[ht]
\centering
\caption{Performance Comparison (1000 Iterations)}
\label{tab:results}
\begin{tabular}{@{}lrrr@{}}
\toprule
\textbf{Operation} & \textbf{OShell} & \textbf{Bash} & \textbf{PowerShell} \\
\midrule
Exponentiation & 1.43 s & 4.5 s & 80.2s \\
Process creation & 0.006 s & 0.006 s & 0.011 s \\
Pipe latency & 7 ms & 11 ms & 89 ms \\
\bottomrule
\end{tabular}
\end{table}

\section{Discussion}
\subsection{Key Findings}
\begin{itemize}
\item 3.15$\times$ faster mathematical operations than Bash (1.43s vs 4.5s) and 56$\times$ faster than PowerShell (1.43s vs 80.2s)
\item Equivalent single-process creation latency to Bash (0.006s) when not in batch mode
\item 36.36\% lower pipe latency than Bash (7ms vs 11ms) through buffer optimizations
\end{itemize}

\subsection{Limitations}
\begin{itemize}
\item Batch mode requires manual activation
\item Floating-point precision differs from Bash
\item Limited to Linux/Windows subsystems
\end{itemize}

\section{Conclusion}
\paragraph{The project successfully demonstrates the implementation of a simple Unix shell in C, encompassing essential features such as command execution, pipelining, input/output redirection, background processing, and multithreaded computation. Special handling of mathematical expressions is built into the shell, increasing computational efficiency specifically for these expressions.}
\paragraph{OShell demonstrates that process management optimizations enable significant performance improvements in shell environments. Future work will explore JIT compilation for mathematical expressions and automatic parallelism detection.}

\bibliographystyle{IEEEtran}
\begin{thebibliography}{10}

\bibitem{bournesh}
S. R. Bourne, 
"The UNIX Shell," 
\textit{Bell System Technical Journal}, 
vol. 57, no. 6, pp. 1971-1990, 
Jul.-Aug. 1978.

\bibitem{modernshell}
M. Greenberg, K. Kallas, N. Vasilakis, 
"Unix Shell Programming: The Next 50 Years," 
in \textit{Proc. HotOS '21}, 
ACM, 2021, pp. 156-162. 
DOI: 10.1145/3458336.3465291

\bibitem{bench}
P. Krysl, J. Chen, 
"Benchmarking Computational Shell Models," 
\textit{Archives of Computational Methods in Engineering}, 
vol. 30, pp. 301-315, 2023. 
DOI: 10.1007/s11831-022-09798-5

\end{thebibliography}

\appendix
\section*{Benchmark Code Samples}

\lstinputlisting[
  style=customc,
  caption={Math Benchmark Code (Bash 5.1)},
  label={lst:bench1},
  xleftmargin=2em
]{benchmark1.c}

\lstinputlisting[
  style=customc,
  caption={Math Benchmark Code (PowerShell 7.3)},
  label={lst:bench2},
  xleftmargin=2em
]{benchmark2.c}


\end{document}